一、Android系统的启动流程
https://juejin.cn/post/7171779955171426334

1. 手机上的BIOS：BootLoader

2. Android的第一个进程：idle
   idle的主要作用
          初始化进程以及内存管理，加载硬件的驱动程序
          创建init进程，该进程的pid=1，init进程是第一个用户空间的进程
          创建kthreadd进程，该进程pid=2，并且该进程仍属于内核空间
          idle进程自己也运行在内核空间

3. 和内核相关的进程：kthreadd
   对于kthreadd进程，我们其实并不需要知道太多，毕竟我们正常开发用不到关注内核相关的代码。我们只需要知道几点，
   kthread的进程pid=2
   内核相关的资源都是由这个进程创建而来的。
   该进程以及由它产生的子进程都运行在内核空间

4. 一切的开始：init进程
   init进程，光听名字我们就知道他的重要性。这个进程也是由idle进程创建而来的，他的pid=1。并且它是第一个属于用户空间的进程。
   init主要作用
   该进程最主要的作用就是fork出了Zygote进程
   同时会创建ServiceManager进程。即我们俗称的服务大管家。

5. 最重要的进程：Zygote
   Zygote英文翻译为受精卵，我们平时启动的所有进程等都是由这个进程复制而来。所谓复制就是，这个进程会复制出两份一模一样的进程，其中一个继续当Zygote进程，另一个进程执行完相关代码就变成了，你想启动的进程。但是在fork出别的进程之前，他要先进行一些初始化，这样fork出来的进程就和他一样自带这些初始化好的功能，而不是在初始化一遍。

   Zygote的主要作用
   创建虚拟机
   注册JNI
   启动ZygoteServer（实际就是Socket，用来跨进程通信）
   preload 预加载资源，之后复制出的进程就都已经是加载过资源的进程了
   启动SystemServer
   循环等待，一旦AMS通知创建进程，就会进行进程分裂。
   Zygote其他
   这里多说一嘴，Zygote进程本身创建了JVM虚拟机，注册了JNI，也就是说我们的代码从这里开始，才真正的开始可以执行Java代码，之前运行的都是C++代码。
   另外，由于在fork进程之前进行了创建虚拟机注册JNI，以及预加载等工作。所以我们fork出的进程从出生开始，就自带了虚拟机，并且已经注册好了JNI代码，相应的资源也已经加载完毕了。

6. 累死累活的工具人：SystemServer
   为啥说它是累死累活的呢，因为几乎所有服务都是由SystemServer创建的。其中包括AMS,WMS,PMS等重要服务，都是运行在该进程上的，并且在该进程上注册到ServiceManager进程中。


7. 柳暗花明有一村：Launcher
   
   各位有没有想过，我们每天滑动手机时的界面到底是什么。其实它和我们开发的手机程序一样，都是一个App。只不过它是由Android系统自动启动的。并且，它可以把我们的所有安装的App全都显示出来，仅此而已。

   当我们点击Launcher上的App图标时，它会和AMS进行通信，AMS又和Zygote进行通信。Zygote进程fork出了一个新进程,并执行相关代码，从而我们编写的App就这样被创建了出来。











